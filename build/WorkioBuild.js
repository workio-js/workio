function d(n){return URL.createObjectURL(new File([n],"workioscript.js",{type:"application/javascript"}))}var c=class{constructor(){this.pool={},this.nextId=0,this.vacantId=[],this.reservedResponse=[]}newTask({resolve:e,reject:t}){let s=null;return this.vacantId.length?(s=this.vacantId[0],this.vacantId.shift()):(s=this.nextId,this.nextId++),this.pool[s]={resolve:e,reject:t},s}setResponse({taskId:e,returnValue:t}){this.pool[e].resolve(t),this.taskGC({taskId:e})}rejectResponse({taskId:e}){this.pool[e].reject("Method not found"),this.taskGC({taskId:e})}taskGC({taskId:e}){this.pool[e]=void 0,e+1===this.nextId?this.nextId--:this.vacantId.push(e)}};var a=class{constructor({workerFn:e,config:t,constructorArgs:s}){let r=new Worker(d(`(async () => {let sudo = crypto.randomUUID();self.postMessage({ sudo });self.close = function() {self.postMessage({ close: true, sudo })};const publicFunctionInterface = {};for(const index in publicFunctionInterface) {if(!(publicFunctionInterface[index] instanceof Function)) {delete publicFunctionInterface[index]}};self.addEventListener("message", async ({ data }) => {if("task" in data) {if(data.task in publicFunctionInterface) {self.postMessage({ returnValue: await publicFunctionInterface[data.task](...data.args), taskId: data.taskId, sudo })} else {self.postMessage({ methodNotFound: true, taskId: data.taskId, sudo })}}if(data.constructorArgs) {let sudo = undefined;Object.assign(publicFunctionInterface, await (${e.toString()})(data.constructorArgs))}}, { passive: true });})()`),{type:"module"}),i=new c,l=null;return r.postMessage({constructorArgs:s}),r.addEventListener("message",({data:o})=>{if(o.sudo)switch(l){case null:l=o.sudo;break;case o.sudo:if(o.close){r.terminate();return}o.returnValue&&i.setResponse(o),o.methodNotFound&&i.rejectResponse(o);break}},{passive:!0}),new Proxy(this,{get(o,f,m){return function(){return new Promise((h,k)=>{let I=i.newTask({resolve:h,reject:k});r.postMessage({task:f,args:[...arguments],taskId:I})})}}})}};var u=class{constructor(){}};var p=class{};var g=class{constructor(e,t){if(!(e instanceof Function))throw new TypeError("workerFn is not a type of function");let s={};switch(t&&t.as?s.type=t.as:s.type="worker",s.type){case"worker":return class extends a{constructor(...r){super({workerFn:e,config:t,constructorArgs:r})}};case"object":return new p(e,t);case"function":return new u(e,t)}}static configure(e){}};export{g as Workio};